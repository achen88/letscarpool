<div id="loader">loading...</div>
<input id="pac-input" class="pac-controls" type="text" placeholder="Search Box">
<input id="calculate-route" class="controls" type="button" value="Calculate Route">
<input id="clear" class="controls" type="button" value="Reset">
<div class="instructions">
  Select a few locations using the search box. To get the optimal route from first location to the last, hit "Calculate Route"/"Get Directions".
  <p></p>
  <div class="instructions-hide" onclick="hideInstructions()">
    Hide instructions
  </div>
</div>
<div id="container">
  <div id="map"></div>
<!--   <div class="panel outer">

    <div class="panel info">

    </div>
  </div> -->
</div>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script>
function hideInstructions() {
  $(".instructions").remove();
}

var markers = [];
var labelIndex = 0;
var bounds = null;

var orderedLocs = [];
var unorderedLocs = []; // needs impl
var optimalRoute = [];

var clearInput = false;
var referButton = false;

function init() {
  bounds = new google.maps.LatLngBounds();
}

function initAutocomplete() {
  init();
  var directionsDisplay = new google.maps.DirectionsRenderer({ suppressMarkers: true });
  var directionsService = new google.maps.DirectionsService;
  var map = new google.maps.Map(document.getElementById('map'), {
    center: {lat: 37.09024, lng: -95.712891},
    zoom: 4,
    mapTypeId: 'roadmap',
    streetViewControl: false,
    mapTypeControl: false
  });
  directionsDisplay.setMap(map);

  // Create the search box and link it to the UI element.
  var input = document.getElementById('pac-input');
  input.style.display = 'block';
  var autocomplete = new google.maps.places.Autocomplete(input);
  map.controls[google.maps.ControlPosition.TOP_CENTER].push(input);
  autocomplete.setFields(['geometry', 'name']);
  map.controls[google.maps.ControlPosition.BOTTOM_CENTER].push(document.getElementById('calculate-route'));
  map.controls[google.maps.ControlPosition.BOTTOM_CENTER].push(document.getElementById('clear'));

  // Bias the autocomplete results towards current map's viewport.
  map.addListener('bounds_changed', function() {
    autocomplete.setBounds(map.getBounds());
  });

  // Listen for the event fired when the user selects a prediction
  autocomplete.addListener('place_changed', function() {
    // fetch place
    var place = autocomplete.getPlace();
    console.log(place.name);
    if (!place.geometry) {
      console.log("Returned place contains no geometry");
      return;
    }

    // add marker
    var marker = addMarker(place.geometry.location, map);
    addInfo(place.name, marker);

    // extend map bounds
    if (place.geometry.viewport) {
      // Only geocodes have viewport.
      bounds.union(place.geometry.viewport);
    } else {
      bounds.extend(place.geometry.location);
    }

    map.fitBounds(bounds);
    clearInput = true;
  });

  input.addEventListener('click', function() {
    if (clearInput) {
      clearInput = false;
      input.value = "";
    }
  })

  $('#calculate-route').on('click', function() {
    if (referButton) {
      referToGoogleMaps();
    } else {
      calculateAndDisplayRoute(directionsService, directionsDisplay);
      referButton = true;
      toggleButton(referButton);
    }
  });
  $('#clear').on('click', function() {
    clearMarkers(directionsDisplay);
    referButton = false;
    toggleButton(referButton);
  });

  google.maps.event.addListenerOnce(map, 'idle', function() {
    setTimeout(function() {
      $('#loader').remove();
    }, 500);
  });
}

function addMarker(location, map) {
  // create and add marker
  var marker = new google.maps.Marker({
    position: location,
    label: (labelIndex++).toString(),
    map: map
  });
  markers.push(marker);
  orderedLocs.push({location: marker.position});
  return marker;
}

function clearMarkers(directionsDisplay) {
  markers.forEach(function(marker) {
    marker.setMap(null);
  });
  markers = [];
  orderedLocs = [];
  directionsDisplay.set('directions', null);
}

function addInfo(name, marker) {
  var contentString = '<div id="infowindow-content">' 
      + '<div class="title">'
      + name
      + '</div>'
      + '</div>';
  var infowindow = new google.maps.InfoWindow({
    content: contentString
  });

  marker.addListener('click', function() {
    infowindow.open(map, marker);
  });
}

function calculateAndDisplayRoute(directionsService, directionsDisplay) {
  directionsService.route({
    origin: orderedLocs[0],
    destination: orderedLocs[orderedLocs.length - 1],
    waypoints: orderedLocs.slice(1, orderedLocs.length - 1),
    optimizeWaypoints: true,
    travelMode: 'DRIVING'
  }, function(response, status) {
    if (status === 'OK') {
      directionsDisplay.setDirections(response);

      // take first route
      // select a route?
      var route = response.routes[0];
      console.log(response.routes);
      console.log(route);
      route.legs.forEach(function(leg) {
        optimalRoute.push(leg.start_address);
      });
      optimalRoute.push(route.legs[route.legs.length - 1].end_address);
    } else {
      window.alert('Directions request failed due to ' + status);
    }
  });
}

function referToGoogleMaps() {
  // to optimize, encode space as '+' not as '%20'
  var baseUrl = 'https://www.google.com/maps/dir/?api=1';
  baseUrl += '&origin=' + encodeURIComponent(optimalRoute[0]);
  var waypoints = '';
  for (var i = 1; i < optimalRoute.length - 1; i++) {
    waypoints += encodeURIComponent(optimalRoute[i]);
    if (i != optimalRoute.length - 2) {
      waypoints += '%7C'; // url-encoded '|''
    }
  };
  baseUrl += '&waypoints=' + waypoints;
  baseUrl += '&destination=' + encodeURIComponent(optimalRoute[optimalRoute.length - 1]);
  window.location.href = baseUrl;
};

function toggleButton(referButton) {
  if (referButton) {
    $('#calculate-route').val(' Get Directions ');
  } else {
    $('#calculate-route').val('Calculate Route');
  }
}
</script>